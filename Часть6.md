# Сборка. Конфигурация. Разработчикам

[Youtube](https://youtu.be/CVUeLZhtdWw)

В данной части видео хотелось бы подробнее рассказать о сборке утилиты.
Все команды описаны в Makefile (открывает)
Основная команда - то `make build`.
Здесь также мы видим build-windows, которая отвечает за сборку бинарного exe файла dam. И build-linux, которая отвечает за сборку под линукс.
Давайте дождемся результат выполнения команды.
Результатом будут каталоги в _build и бинарные файлы в них.
Весь процесс создания утилиты происходит в контейнерах docker, шаблон для сборки находится в src/make/docker
В проекте есть возможность запустить юнит тесты командой `make test` и проверку кода проекта линтером `make lint`.
Данные команды также выполняются в контейнерах.
Таким образом сборка бинарных файлов проекта, запуск теста и линтера никак не привязаны к версии go в системе. Для работы с проектом нам нужен лишь make.
Но это не отменяет сборку и тесты при помощи стандартных go build и go test.
`make clean` чистит систему от каталогов сборки и временных образов docker.

Также есть команда `make app-linux`. Она создает установочный образ приложения dam.
Это приложение при установке через dam install обновляет саму утилиту dam, перезаписывая ей в системе. 
Т.е. получается при помощи данного приложения утилита обновляет саму себя.
`dam list`
`whereis dam`

Теперь давайте посмотрим конфигурацию утилиты. На текущий момент dam может конфигурироваться следующими способами:
- при помощи зарезервированных переменных окружения с префиксом dam. Их список был показан в предыдущих видео.
- при помощи флагов
- либо при сборке утилиты при помощи конфиг-файла
Давайте посмотрим файл конфигурации: config/sys.config.go

Как мы видим все опции конфигурации разделены на группы, чтобы в них было проще ориентироваться.
Для глобальных опций:
В PROJECT_NAME и PROJECT_VERSION задаются имя проекта и версия, которые используются в сборке приложения, а также его логах.
Версия соответствует тэгу на GitHub.

Далее идут опции, отвечающие за отображение сообщений утилиты в stdout
COLOR_ON - разрешает или запрещает подсветку выводимых dam логов.
Например, цвет ошибок или цвет найденых приложений при search.
Опция нужна, когда dam используется, например, во время выполнении роли ansible.
В этом случае спецсимволы выводимые совместно с ошибками делают сообщения трудно читаемыми.
Поэтому опцией отключается цвет у текста.
DECORATE_MAX_DISPLAY_WIDTH - рабочая область экрана для утилиты в символах.
Чтобы не выходить за данную область, dam будет в командах list и list repos будет упрощать выводимый текст.
DECORATE_RAW_SEPARATOR - разделитель полей при использовании команд list и listrepos с флагом `--raw`.
DECORATE_BOOL_FLAG_SYMBOL - при выводе listrepos можно увидеть выбранный дефолтный репозиторий.
Данный символ, сейчас в виде звездочки, показывает, какой из репозиториев выбран.

Далее идут опции базы данных. На текущий момент dam работает только с одним типом базы - это текстовые файлы.
В будущем число данных типов будет расширятся.
Сейчас, преимуществом использования текстовых файлов в db, является то, что нет необходимости в установке сторонних продуктов для работы с DAM.

FILES_DB_SEPARATOR и FILES_DB_BOOL_FLAG_SYMBOL это символы по аналогии с командой listrepos определяют структуру хранения данных в текстовых файлах.
Это разделитель полей и символ булевого флага.
FILES_DB_FILES_PERMISSIONS - это права доступа для файлов базы данных поумолчанию.
С такой маской  файлы создаются в unix системе при первоначальной инициализации утилиты.
FILES_DB_USE_USER_CACHE_DIR - при использовании данной опции переопределяется следующие за ней опции, отвечающие за размещение файлов базы данных.
Если данная опция true. То в дальнейших настройках конфига будут подразумеваться пути относительно кэша-каталога у пользователя.
Для windows этот каталог определен в переменной окружения LocalAppData. В linux home .cache (показывает).
Если данная опция false то последующие опции могут быть как абсолютные пути, так и относительные, в зависимости того каталога, где запускается dam.

Далее следует тип используемой виртуализации VIRTUALIZATION_TYPE - это docker.
Следом идут опции поиска в репозиториях, это - SEARCH_PROTOCOL_STRATEGY.
В данной опции перечислены протоколы для работы с registry.
Во время работы из данной настройки слева направо идет подстановка протоколов в урл для поиска,
до тех пор пока ответ от registry не будет положительный.
Т.е. для одного тэга образа docker существует несколько registry с разными протоколами https и http.
Данная опция определяет в какой последовательности они будут пинговаться.
SEARCH_MAX_CONNECTIONS - внутренняя опция для web-запросов  к registry, определяет   число повторных соединений (keep-alive).
SEARCH_TIMEOUT_MS - ожидание ответа от registry в милисекундах.
SEARCH_OFFICIAL_REPO_APPS_LIMIT - число выводимых при поиске приложений для официального репозитория.
Здесь в коментариях указано, что оно от 1 до 100 (это внутреннее ограничение апи docker hub).
SEARCH_INTERNAL_REPO_APPS_LIMIT - число выводимых при поиске приложений для локального registry.

Далее идут опции для официального репозитория,
Это урл для аутентификации в docker hub OFFICIAL_REGISTRY_AUTH_URL
Основной url для API OFFICIAL_REGISTRY_URL и имя репозитория в dam по умолчанию при инициализации.

Далее идут опции, определяющие настройки репозитория по умолчанию. Данные опции в основном используются при импорте и установке из архива.
Новый репозиторий создается с префиксом в имени NEW_REPO_PREFIX и постфиксом - это число не более NEW_REPO_POSTFIX_LIMIT.
Символ разделитель LABEL_REPOS_SEPARATOR используется в метке DAM_APP_SERVERS для разделения репозиториев.
Более подробно о данной метке рассказано в предыдущих видео
И UNKNOWN_REPO_NAME - определяет отображаемое имя репозитория в dam list когда репозиторий был удален из системы или отображаемых данных по нему нет.
Id такого репозитория будет UNKNOWN_REPO_ID

Далее идет опция для docker DOCKER_API_VERSION, которая определяет версию апи для клиента docker.
Рекомендуется менять данную версию совместно с разработчиками, т.к. пакеты go для docker могут не поддерживать версию, отличную от по умолчанию.
Далее. Определяются типы сортировок. Данные сортировки используются для сортировки имени приложения SORT_APP_TYPE и его версии SORT_VERSION_TYPE
Они нужны для вывода найденного в registry на экран.

Далее идут настройки файловой системы проекта. Более подробно об этой структуре dam рассказано в предыдущих видео.
FS_META_DIR_NAME - определяет имя метадиректории для проекта приложения dam.
FS_DOCKERFILE_NAME - имя докер файла
FS_ENV_FILE_NAME - файл с переменными окружения, которые будут использованы для dam при создании приложения при docker create.
В предыдущих видео я не рассказывал о данной возможности. Но если в каталоге meta создать файл ENVIRONMENT.
То переменные окружения из него и их значения будут использованы для замены шаблонов в файлах с расширением .exp.
Данный файл удобно использовать, когда команда создания приложения dam запускается из роли ansible.

FS_INSTALL_FILE_NAME - определяет имя файла install в каталоге meta для установки приложения.
Здесь может быть имя соответствующего power shell скрипта.
И соответственно FS_UNINSTALL_FILE_NAME определяет имя файла для удаления приложения dam.
FS_DESCRIPTION_FILE_NAME - имя файла для описания приложения.
FS_EXPAND_META_FILE - опция определяет расширение файлов, в которых подлежат модификации переменные окружения в соответствии с шаблоном
FS_TMP_META_PATH - путь куда извлекается из контейнера каталог meta при установке,
далее из этого каталога будут запускаться скрипты.
Здесь указан относительный путь поэтому каталог будет создаваться в той же директории, откуда запущен dam. И удаляться после установки.

Далее идут опции для метки multiversion/ MULTIVERSION_TRUE_FLAG и MULTIVERSION_FALSE_FLAG.
Данные опции определяют какой строкой будет обозначаться метка multiversion при выводе информации в dam info.

Ниже находится конфигурирование зарезервированных переменных.
Они используются в основном при создании приложения dam create.
Здесь определяются названия данных переменных в системе (выделяет). Дефолтные значения для имени приложения и его версия.
А также префикс OS_ENV_PREFIX.

Хочу обратить внимание - не все переменные окружения системы в .exp файле будут заменены, даже если они соответствуют шаблону.
Давайте откроем какой-нибудь exp файл. (открывает).
Значения переменных из системы берутся только с данным префиксом.
Следует отметить, что DAM_APP_TAG зарезервированная переменная, поэтому у нее есть значение по умолчанию.
Если же мы добавим в файл `# TEST ${TEST}` то в этой строке замены не произойдет
Т.к. переменная не имеет префикса DAM_.

Следует отметить, что такие переменные для замены должны быть обьявлены в Dockerfile и файла Environment.
В этом случае префикс DAM_ не требуется.
Для примера обьявим переменную TEST в Dockerfile.
После этого добавленная .exp файле строка с шаблоном будет заменяться при создании приложения.
Далее.

Перейдем к группе опций экспорта:
EXPORT_APP_SEPARATOR - определяет символ, который будет разделять поля в файле экспорта приложений
EXPORT_APPS_FILE_NAME - имя файла со списком приложений внутри архива

Завершают конфигурацию утилиты опции Save.
Данные опции используются не только для сохранения приложения, но также и в экспорте.
SAVE_OPTIONAL_SEPARATOR и SAVE_FILE_SEPARATOR - это разделители для формирования имени сохраняемого файла.
Далее определены расширения для сохраняемого и временного файла.
Ниже - алгоритм для вычисления контрольной суммы. При создании архива хэш-сумма  добавляется в его имя.
Далее при импорте эта сумма сверяется.
И наконец,  SAVE_MANIFEST_FILE - это имя файла в сохраненном образе докера.
Данный файл необходим для модификации, чтобы привязать к образу имена тэгов.
После изменения этого файла, архив с образом docker перезаписывается.

В заключение давайте посмотрим репозиторий с проектом dam. Я бы хотел рассказать общую информацию для разработчиков по проекту.
В репозитории присутствует README как английское, так и русское.
В каталоге docs есть информация для разработчиков, а также каталог с описаниями команд.
В данных статьях уже описана большая часть работы с dam, той что объяснялась в видео.
Вся разработка ведется по gitflow. Основная ветка в которую вливается код из отдельных веток - это 1.x.x.
Далее из этой ветки код вливается в мастер и релизится.
Проект опенсорсный под лицензией Apache 2.0. Основная цель - автоматизировать работу с docker.
На текущий момент необходимый минимальный набор возможностей dam готов.
Кого заинтересовал сам проект и есть новые идеи - добро пожаловать.
